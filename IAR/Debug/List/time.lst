###############################################################################
#
# IAR C/C++ Compiler V6.40.1.950/W32 for MSP430           10/Mar/2017  17:23:07
# Copyright 1996-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  regvar
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430
#    Source file   =  E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\time.c
#    Command line  =  
#        E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\time.c -lcN
#        E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\IAR\Debug\List -o
#        E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\IAR\Debug\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430G2332__ -e --double=32 --regvar_r4 --dlib_config "C:\Program
#        Files (x86)\IAR Systems\Embedded Workbench 7.3\430\lib\dlib\dl430fn.h"
#        -I ..\ -I .\ -On
#    List file     =  
#        E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\IAR\Debug\List\time.lst
#    Object file   =  
#        E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\IAR\Debug\Obj\time.r43
#
###############################################################################

E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\time.c
      1          //time.c
      2          
      3          #include "main.h"
      4          #include "time.h"
      5          
      6          
      7          //Declarations
      8          extern __regvar __no_init tFlags 	f 	 @ __R4; 
      9          
     10          //--------------------------------------------------------------------------------
     11          // Function		: void VLO_TimerCalibr(void)
     12          // Parameters	: None
     13          // Return		: None
     14          // Description	: Calculation calibration value of VLO timer
     15          //--------------------------------------------------------------------------------
     16          void VLO_TimerCalibr(void) {
     17          	u16 clk;
     18          	
     19          	// Start timer 1MHz
     20          	TACTL = TASSEL_2 + MC_1 + ID_3;     	 	// SMCLK, up mode  / 8
     21          	//			
     22          	CCR0 = 62500 - 1;	                    // Period 0.5sec
     23          	CCTL1 = 0; 			                    // CCR1 reset/set
     24          	TACCTL0 = CCIE;							// Разрешаем прерывание таймера по достижению значения TACCCR0.
     25          	//
     26          	clk = 0;
     27          	while (1) {
     28          		if (fTimer50msOn) {
     29          			fTimer50msOn = 0;
     30          			clk++;
     31          		}
     32          		if (fTimerA_On) {
     33          			fTimerA_On = 0;
     34          			clk++;
     35          			break;
     36          		}
     37          	}
     38          	TACTL = 0;  
     39          	TACCTL0 = 0;				// Запрещаем прерывание таймера по достижению значения TACCCR0.
     40          	//
     41          	if (clk != CONFIG->timer_calibr) {
     42          		StoragePropertyWord(eeTIMER_CALIBR_OFFSET, clk * 2);
     43          		#if (CRC_ENABLE == 1)
     44          		SavePropertyCS();
     45          		#endif
     46          	}
     47          	//
     48          }
     49          
     50          
     51          //--------------------------------------------------------------------------------
     52          // Function		: void Timer_A0_Init(void)
     53          // Parameters	: period in us (1..65535) - for 1 MHz DCO
     54          // Return		: None
     55          // Description	: Function initiates delay
     56          //--------------------------------------------------------------------------------
     57          void SysTimerInit(void) {
     58          	_BIC_SR(GIE);    					// Запрещаем прерывания
     59          	//
     60          
     61          //	fLPM3 = 0;							// Выключаем режим энергосбережения	
     62          	//
     63          	TA0R = 0;
     64          	TA0CTL 	 = TASSEL_2 + MC_1 + ID_0;  // SMCLK, up mode, div = 1
     65          	TA0CCR0  = SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
     66          	TA0CCTL0 = CCIE;					// Разрешаем прерывание таймера по достижению значения TACCCR0.
     67          	//
     68          	_BIS_SR(GIE);    					// Разрешаем прерывания
     69          
     70          }
     71          
     72          //--------------------------------------------------------------------------------
     73          // Function		: __interrupt void CCR0_ISR(void)
     74          // Parameters	: None
     75          // Return		: None
     76          // Description	: TIMER0 Interrupt routine
     77          //--------------------------------------------------------------------------------
     78          #pragma vector = TIMER0_A0_VECTOR
     79          __interrupt void CCR0_ISR(void) {
     80            fTimerA_On = 1;
     81          	/*
     82          	if (fRedLedFlash) {
     83          		fRedLedFlash = 0;
     84          		RED_CLR();
     85          		//
     86          		fTimerA_Enable = 0;
     87          		TACTL = 0;  
     88          		TACCTL0 = 0;				// Запрещаем прерывание таймера по достижению значения TACCCR0.
     89          		//
     90          		return;
     91          	}
     92          	*/
     93          } // CCR0_ISR
     94          

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   CCR0_ISR
      2   SysTimerInit
      4   VLO_TimerCalibr
        4   -> SavePropertyCS
        4   -> StoragePropertyWord


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       4  CCR0_ISR
       2  CCR0_ISR::??INTVEC 18
      28  SysTimerInit
       2  TA0CCR0
       2  TA0CCTL0
       2  TA0CCTL1
       2  TA0CTL
       2  TA0R
      80  VLO_TimerCalibr

 
 112 bytes in segment CODE
  10 bytes in segment DATA16_AN
   2 bytes in segment INTVEC
 
 112 bytes of CODE  memory
   0 bytes of CONST memory (+  2 bytes shared)
   0 bytes of DATA  memory (+ 10 bytes shared)

Errors: none
Warnings: none
