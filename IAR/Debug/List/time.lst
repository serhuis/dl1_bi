###############################################################################
#
# IAR C/C++ Compiler V6.40.1.950/W32 for MSP430           27/Mar/2017  10:40:45
# Copyright 1996-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  regvar
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430
#    Source file   =  E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\time.c
#    Command line  =  
#        E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\time.c -lcN
#        E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\IAR\Debug\List -o
#        E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\IAR\Debug\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430G2332__ -e --double=32 --regvar_r4 --dlib_config "C:\Program
#        Files (x86)\IAR Systems\Embedded Workbench 7.3\430\lib\dlib\dl430fn.h"
#        -I ..\ -I .\ -On
#    List file     =  
#        E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\IAR\Debug\List\time.lst
#    Object file   =  
#        E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\IAR\Debug\Obj\time.r43
#
###############################################################################

E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\time.c
      1          //time.c
      2          
      3          #include "main.h"
      4          #include "time.h"
      5          
      6          
      7          //Declarations
      8          extern __regvar __no_init tFlags 	f 	 @ __R4; 
      9          
     10          //--------------------------------------------------------------------------------
     11          // Function		: void VLO_TimerCalibr(void)
     12          // Parameters	: None
     13          // Return		: None
     14          // Description	: Calculation calibration value of VLO timer
     15          //--------------------------------------------------------------------------------
     16          void VLO_TimerCalibr(void) {
     17          	u16 clk;
     18          	
     19          	// Start timer 1MHz
     20          	TACTL = TASSEL_2 + MC_1 + ID_3;     	 	// SMCLK, up mode  / 8
     21          	//			
     22          	CCR0 = 62500 - 1;	                    // Period 0.5sec
     23          //	CCTL1 = 0; 			                    // CCR1 reset/set
     24          	TACCTL0 = CCIE;							// Разрешаем прерывание таймера по достижению значения TACCCR0.
     25          	//
     26          	clk = 0;
     27          	while (1) {
     28          		if (fTimer50msOn) {
     29          			fTimer50msOn = 0;
     30          			clk++;
     31          		}
     32          		if (fTimerA_On) {
     33          			fTimerA_On = 0;
     34          			clk++;
     35          			break;
     36          		}
     37          	}
     38          	TACTL = 0;  
     39          	TACCTL0 = 0;				// Запрещаем прерывание таймера по достижению значения TACCCR0.
     40          	//
     41          	if (clk != CONFIG->timer_calibr) {
     42          		StoragePropertyWord(eeTIMER_CALIBR_OFFSET, clk * 2);
     43          		#if (CRC_ENABLE == 1)
     44          		SavePropertyCS();
     45          		#endif
     46          	}
     47          	//
     48          }
     49          
     50          
     51          //--------------------------------------------------------------------------------
     52          // Function		: void Timer_A0_Init(void)
     53          // Parameters	: period in us (1..65535) - for 1 MHz DCO
     54          // Return		: None
     55          // Description	: Function initiates delay
     56          //--------------------------------------------------------------------------------
     57          void SysTimerInit(void) {
     58          	_BIC_SR(GIE);    					// Запрещаем прерывания
     59          	//
     60          
     61          	TA0R = 0;
     62          	TA0CTL 	 = TASSEL_2 + MC_1 + ID_0;  // SMCLK, up mode, div = 1
     63          	TA0CCR0  = SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
     64          	TA0CCR1 = DELAY_1MS-1;							//for 1 ms delay;
     65          	TA0CCTL0 = CCIE;					// Разрешаем прерывание таймера по достижению значения TACCCR0.
     66          	//
     67          	_BIS_SR(GIE);    					// Разрешаем прерывания
     68          }
     69          
     70          void T0_delay(void)
     71          {
     72          	TA0CCTL1 = CCIE;
     73          }
     74          
     75          //--------------------------------------------------------------------------------
     76          // Function		: __interrupt void CCR0_ISR(void)
     77          // Parameters	: None
     78          // Return		: None
     79          // Description	: TIMER0 Interrupt routine
     80          //--------------------------------------------------------------------------------
     81          #pragma vector = TIMER0_A0_VECTOR
     82          __interrupt void CCR0_ISR(void) {
     83            fTimerA_On = 1;
     84          	__bic_SR_register_on_exit(LPM1_bits);		//exit LowPower mode
     85          } // CCR0_ISR
     86          
     87          #pragma vector = TIMER0_A1_VECTOR
     88          __interrupt void CCR1_ISR(void) {
     89            fIrTimerOn = 1;
     90          	TACCTL1 = 0;
     91          	__bic_SR_register_on_exit(LPM1_bits);		//exit LowPower mode
     92          } // CCR0_ISR

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   CCR0_ISR
      4   CCR1_ISR
      2   SysTimerInit
      2   T0_delay
      4   VLO_TimerCalibr
        4   -> SavePropertyCS
        4   -> StoragePropertyWord


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      10  CCR0_ISR
       2  CCR0_ISR::??INTVEC 18
      16  CCR1_ISR
       2  CCR1_ISR::??INTVEC 16
      34  SysTimerInit
       8  T0_delay
       2  TA0CCR0
       2  TA0CCR1
       2  TA0CCTL0
       2  TA0CCTL1
       2  TA0CTL
       2  TA0R
      76  VLO_TimerCalibr

 
 144 bytes in segment CODE
  12 bytes in segment DATA16_AN
   4 bytes in segment INTVEC
 
 144 bytes of CODE  memory
   0 bytes of CONST memory (+  4 bytes shared)
   0 bytes of DATA  memory (+ 12 bytes shared)

Errors: none
Warnings: none
