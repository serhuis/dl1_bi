###############################################################################
#
# IAR C/C++ Compiler V6.40.1.950/W32 for MSP430           13/Mar/2017  17:18:05
# Copyright 1996-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  regvar
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430
#    Source file   =  E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\time.c
#    Command line  =  
#        E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\time.c -lcN
#        E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\IAR\Debug\List -o
#        E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\IAR\Debug\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430G2332__ -e --double=32 --regvar_r4 --dlib_config "C:\Program
#        Files (x86)\IAR Systems\Embedded Workbench 7.3\430\lib\dlib\dl430fn.h"
#        -I ..\ -I .\ -On
#    List file     =  
#        E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\IAR\Debug\List\time.lst
#    Object file   =  
#        E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\IAR\Debug\Obj\time.r43
#
###############################################################################

E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\time.c
      1          //time.c
      2          
      3          #include "main.h"
      4          #include "time.h"
      5          
      6          
      7          //Declarations
      8          extern __regvar __no_init tFlags 	f 	 @ __R4; 
      9          
     10          //--------------------------------------------------------------------------------
     11          // Function		: void VLO_TimerCalibr(void)
     12          // Parameters	: None
     13          // Return		: None
     14          // Description	: Calculation calibration value of VLO timer
     15          //--------------------------------------------------------------------------------
     16          void VLO_TimerCalibr(void) {
     17          	u16 clk;
     18          	
     19          	// Start timer 1MHz
     20          	TACTL = TASSEL_2 + MC_1 + ID_3;     	 	// SMCLK, up mode  / 8
     21          	//			
     22          	CCR0 = 62500 - 1;	                    // Period 0.5sec
     23          	CCTL1 = 0; 			                    // CCR1 reset/set
     24          	TACCTL0 = CCIE;							// Разрешаем прерывание таймера по достижению значения TACCCR0.
     25          	//
     26          	clk = 0;
     27          	while (1) {
     28          		if (fTimer50msOn) {
     29          			fTimer50msOn = 0;
     30          			clk++;
     31          		}
     32          		if (fTimerA_On) {
     33          			fTimerA_On = 0;
     34          			clk++;
     35          			break;
     36          		}
     37          	}
     38          	TACTL = 0;  
     39          	TACCTL0 = 0;				// Запрещаем прерывание таймера по достижению значения TACCCR0.
     40          	//
     41          	if (clk != CONFIG->timer_calibr) {
     42          		StoragePropertyWord(eeTIMER_CALIBR_OFFSET, clk * 2);
     43          		#if (CRC_ENABLE == 1)
     44          		SavePropertyCS();
     45          		#endif
     46          	}
     47          	//
     48          }
     49          
     50          
     51          //--------------------------------------------------------------------------------
     52          // Function		: void Timer_A0_Init(void)
     53          // Parameters	: period in us (1..65535) - for 1 MHz DCO
     54          // Return		: None
     55          // Description	: Function initiates delay
     56          //--------------------------------------------------------------------------------
     57          void SysTimerInit(void) {
     58          	_BIC_SR(GIE);    					// Запрещаем прерывания
     59          	//
     60          
     61          //	fLPM3 = 0;							// Выключаем режим энергосбережения	
     62          	//
     63          	TA0R = 0;
     64          	TA0CTL 	 = TASSEL_2 + MC_1 + ID_0;  // SMCLK, up mode, div = 1
     65          	TA0CCR0  = SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
     66          	TA0CCR1 = DELAY_1MS;							//for 1 ms delay;
     67          	TA0CCTL0 = CCIE;					// Разрешаем прерывание таймера по достижению значения TACCCR0.
     68          	//
     69          	_BIS_SR(GIE);    					// Разрешаем прерывания
     70          
     71          }
     72          
     73          void T0_delay(void)
     74          {
     75          	TA0CCTL1 = CCIE;
     76          }
     77          
     78          //--------------------------------------------------------------------------------
     79          // Function		: __interrupt void CCR0_ISR(void)
     80          // Parameters	: None
     81          // Return		: None
     82          // Description	: TIMER0 Interrupt routine
     83          //--------------------------------------------------------------------------------
     84          #pragma vector = TIMER0_A0_VECTOR
     85          __interrupt void CCR0_ISR(void) {
     86            fTimerA_On = 1;
     87          	/*
     88          	if (fRedLedFlash) {
     89          		fRedLedFlash = 0;
     90          		RED_CLR();
     91          		//
     92          		fTimerA_Enable = 0;
     93          		TACTL = 0;  
     94          		TACCTL0 = 0;				// Запрещаем прерывание таймера по достижению значения TACCCR0.
     95          		//
     96          		return;
     97          	}
     98          	*/
     99          } // CCR0_ISR
    100          
    101          #pragma vector = TIMER0_A1_VECTOR
    102          __interrupt void CCR1_ISR(void) {
    103            fIrTimerOn = 1;
    104          	TACCTL1 = 0;
    105          	/*
    106          	if (fRedLedFlash) {
    107          		fRedLedFlash = 0;
    108          		RED_CLR();
    109          		//
    110          		fTimerA_Enable = 0;
    111          		TACTL = 0;  
    112          		TACCTL0 = 0;				// Запрещаем прерывание таймера по достижению значения TACCCR0.
    113          		//
    114          		return;
    115          	}
    116          	*/
    117          } // CCR0_ISR

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   CCR0_ISR
      4   CCR1_ISR
      2   SysTimerInit
      2   T0_delay
      4   VLO_TimerCalibr
        4   -> SavePropertyCS
        4   -> StoragePropertyWord


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       4  CCR0_ISR
       2  CCR0_ISR::??INTVEC 18
      10  CCR1_ISR
       2  CCR1_ISR::??INTVEC 16
      34  SysTimerInit
       8  T0_delay
       2  TA0CCR0
       2  TA0CCR1
       2  TA0CCTL0
       2  TA0CCTL1
       2  TA0CTL
       2  TA0R
      80  VLO_TimerCalibr

 
 136 bytes in segment CODE
  12 bytes in segment DATA16_AN
   4 bytes in segment INTVEC
 
 136 bytes of CODE  memory
   0 bytes of CONST memory (+  4 bytes shared)
   0 bytes of DATA  memory (+ 12 bytes shared)

Errors: none
Warnings: none
