###############################################################################
#
# IAR C/C++ Compiler V6.40.1.950/W32 for MSP430           07/Mar/2017  15:57:16
# Copyright 1996-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  regvar
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430
#    Source file   =  E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\main.c
#    Command line  =  
#        E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\main.c -lcN
#        E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\IAR\Debug\List -o
#        E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\IAR\Debug\Obj --debug
#        -D__MSP430G2332__ -e --double=32 --regvar_r4 --dlib_config "C:\Program
#        Files (x86)\IAR Systems\Embedded Workbench 7.3\430\lib\dlib\dl430fn.h"
#        -I ..\ -I .\ -Oh
#    List file     =  
#        E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\IAR\Debug\List\main.lst
#    Object file   =  
#        E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\IAR\Debug\Obj\main.r43
#
###############################################################################

E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\main.c
      1          /**********************************************************************************
      2           *
      3           *      ASD-10QR MAIN routine
      4           * 
      5           **********************************************************************************
      6           * FileName:        main.c
      7           * Version:			1.00
      8           *
      9           * Processor:       MSP430G2xxx
     10           * Complier:        IAR Workbench for MSP430 v4.50 or higher
     11           *                  
     12           * Company:         ARTON
     13           *
     14           * Software License Agreement
     15           *
     16           * The software supplied herewith by ARTON Incorporated
     17           * (the "Company") for its devices is intended and
     18           * supplied to you, the Company's customer, for use solely and
     19           * exclusively on ARTON Inc products. The
     20           * software is owned by the Company and/or its Author, and is
     21           * protected under applicable copyright laws. All rights are reserved.
     22           * Any use in violation of the foregoing restrictions may subject the
     23           * user to criminal sanctions under applicable laws, as well as to
     24           * civil liability for the breach of the terms and conditions of this
     25           * license.
     26           *
     27           * THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
     28           * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
     29           * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
     30           * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
     31           * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
     32           * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
     33           *
     34           *
     35           * Author               Date      	Version	  		Comment
     36           *--------------------------------------------------------------------------------
     37           * Oleg Semeniuk	 16.01.2014    	1.00		Release for v1.00
     38           *
     39           *********************************************************************************/
     40          
     41          
     42          /*********************************************************************************/
     43          /*                                 INCLUDES                                      */
     44          /*********************************************************************************/
     45          
     46          
     47          #include <stdio.h>                    /* standard I/O .h-file                */
     48          #include <string.h>                   /* string and memory functions         */
     49          
     50          
     51          #include  "main.h"
     52          
     53          
     54          
     55          /*********************************************************************************/
     56          /*                                 VARIABLES                                     */
     57          /*********************************************************************************/
     58          
     59          __regvar __no_init tFlags 	f 	 @ __R4; 	// Set of state machine flags
     60          
     61          //
     62          u16		timerMain;					// Текущее значение главного таймера
     63          u16		mainPeriodCounter;			// Counter of main time period
     64          u8 		DeviceMode; 				// Mode of device
     65          
     66          tFault	DeviceFault = {0};			// Current Faults flags
     67          u16		tempC;						// Current temperature in deg C
     68          
     69          u8 		Timer50msCounter = 0;		// Counter of 50ms ticks
     70          
     71          volatile u32	led_r;
     72          volatile u32	led_y;
     73          volatile u32	led_sh = 0;
     74          
     75          u8 		fTimerA1_On = 0;
     76          
     77          //const u8 fault_sequence[4 * 2] = {MODE_FAULT, 10, MODE_NORM, 5, MODE_FIRE, 0, 0};	// 0 = ~~
     78          
     79          u8	reference;
     80          tCfgReg	cfg_reg;
     81          
     82          u8	jp1_state = 0;	// 0 - JP1 Open, 1 - JP1 Close
     83          
     84          u8	adc_process = 0;		// ADC low level semafore
     85          
     86          u16	light_timer = 0;	// For led lighting
     87          
     88          u8	light_sync = 0;		// For led lighting syncronisation
     89          
     90          
     91          /*********************************************************************************/
     92          /*                                FUNCTIONS                                      */
     93          /*********************************************************************************/
     94          // --- Declarations ---
     95          
     96          //u16  AverageData(u16 * data_ptr, u8 len);
     97          //u8   RX_PacketParser(void);
     98          //void ADC_Measure(u16 ch, u16 refout, u8 count);
     99          //void ADC_Measure_TEMP(u16 ch, u16 refout, u8 count);
    100          
    101          void Timer_A0_Init(void);
    102          //void Timer_A_SetDelay(u16 period);
    103          void TimerA0_DelayUs(u16 time);
    104          //void Timer_A_Off(void);
    105          void JP1_Define(void);
    106          
    107          
    108          
    109          
    110          //--------------------------------------------------------------------------------
    111          // Function		: void VLO_TimerCalibr(void)
    112          // Parameters	: None
    113          // Return		: None
    114          // Description	: Calculation calibration value of VLO timer
    115          //--------------------------------------------------------------------------------
    116          void VLO_TimerCalibr(void) {
    117          	u16 clk;
    118          	
    119          	// Start timer 1MHz
    120          	TACTL = TASSEL_2 + MC_1 + ID_3;     	 	// SMCLK, up mode  / 8
    121          	//			
    122          	CCR0 = 62500 - 1;	                    // Period 0.5sec
    123          	CCTL1 = 0; 			                    // CCR1 reset/set
    124          	TACCTL0 = CCIE;							// Разрешаем прерывание таймера по достижению значения TACCCR0.
    125          	//
    126          	clk = 0;
    127          	while (1) {
    128          		if (fTimer50msOn) {
    129          			fTimer50msOn = 0;
    130          			clk++;
    131          		}
    132          		if (fTimerA_On) {
    133          			fTimerA_On = 0;
    134          			clk++;
    135          			break;
    136          		}
    137          	}
    138          	//
    139          	//SoundStop();							// Disable interrupts of timer
    140          	TACTL = 0;  
    141          	TACCTL0 = 0;				// Запрещаем прерывание таймера по достижению значения TACCCR0.
    142          	//
    143          	if (clk != CONFIG->timer_calibr) {
    144          		StoragePropertyWord(eeTIMER_CALIBR_OFFSET, clk * 2);
    145          		#if (CRC_ENABLE == 1)
    146          		SavePropertyCS();
    147          		#endif
    148          	}
    149          	//
    150          }
    151          
    152          //--------------------------------------------------------------------------------
    153          // Function		: void DeviceStart(void)
    154          // Parameters	: None
    155          // Return		: None
    156          // Description	: Function executes initialization variable at start of device
    157          //--------------------------------------------------------------------------------
    158          void DeviceStart(void) {
    159          
    160          	DeviceFault.byte = 0;		// Reset faults flags
    161          	//		
    162          	VLO_TimerCalibr();			// Calibration VLO Timer
    163          	//
    164          }
    165          
    166          //--------------------------------------------------------------------------------
    167          // Function		: void VLO_TimerCalibr(void)
    168          // Parameters	: None
    169          // Return		: None
    170          // Description	: Calculation calibration value of VLO timer
    171          //--------------------------------------------------------------------------------
    172          u16 VLO_GetPeriod(void) {
    173          	
    174          	// Start timer 8MHz
    175          	TACTL = TASSEL_2 + MC_1;           	 	// SMCLK, up mode
    176          	//			
    177          	CCR0 =0xFFFF;                    		// Period 2.5mS
    178          	CCTL1 = 0; 			                    // CCR1 reset/set
    179          	TACCTL0 = 0;							// Разрешаем прерывание таймера по достижению значения TACCCR0.
    180          	//
    181          	while (fTimer50msOn == 0) {}
    182          	fTimer50msOn = 0;
    183          	//while (fTimer50msOn == 0) {}
    184          	
    185          	return TAR;
    186          	
    187          }
    188          
    189          //--------------------------------------------------------------------------------
    190          // Function		: void Timer_A_SetDelay(u16 period)
    191          // Parameters	: period in us (1..65535) - for 8 MHz DCO
    192          // Return		: None
    193          // Description	: Function initiates delay
    194          //--------------------------------------------------------------------------------
    195          void Timer_A_SetDelay(u16 period) {
    196          	
    197          	if (period == 0) return;
    198          	
    199          	_BIC_SR(GIE);    					// Запрещаем прерывания
    200          	
    201          	fTimerA_Enable = 1;
    202          	fTimerA_Repeat = 0;
    203          	//
    204          	fLPM3 		= 0;					// Выключаем режим энергосбережения	
    205          	//
    206          	TA0R = 0;
    207          	TACTL 	 = TASSEL_2 + MC_1 + ID_3;  // SMCLK, up mode, div = 8
    208          	CCR0 	 = period - 1;      		// Period T(us) * F(MHz)
    209          	TACCTL0 = CCIE;						// Разрешаем прерывание таймера по достижению значения TACCCR0.
    210          	//
    211          	_BIS_SR(GIE);    					// Разрешаем прерывания
    212          }
    213          
    214          //--------------------------------------------------------------------------------
    215          // Function		: void TimerA1_DelayUs(u16 time)
    216          // Parameters	: period in us (1..32768) - for 1 MHz DCO
    217          // Return		: None
    218          // Description	: Function initiates 
    219          //--------------------------------------------------------------------------------
    220          #pragma optimize=none
    221          void TimerA0_DelayUs(u16 time) {
    222          	_BIC_SR(GIE);    					// Запрещаем прерывания
    223          	
    224          	//
    225          	TA0R = 0;
    226          	TA0CTL 	 = TASSEL_2 + MC_1;     	// SMCLK, up mode, div = 8
    227          	TA0CCR0 	 = time - 1 - 35;      	   	// Period T(us) * F(MHz)
    228          	//
    229          	_BIS_SR(GIE);    						// Разрешаем прерывания
    230          	
    231          	while ((TA0CCTL0 & CCIFG) == 0);
    232          	
    233          	TA0CTL 	 = 0;
    234          	TA0CCTL0 = 0;
    235          
    236          }
    237          
    238          
    239          //--------------------------------------------------------------------------------
    240          // Function		: void Timer_A1_Init(void)
    241          // Parameters	: period in us (1..65535) - for 1 MHz DCO
    242          // Return		: None
    243          // Description	: Function initiates delay
    244          //--------------------------------------------------------------------------------
    245          void Timer_A0_Init(void) {
    246          	_BIC_SR(GIE);    					// Запрещаем прерывания
    247          	//
    248          
    249          //	fLPM3 = 0;							// Выключаем режим энергосбережения	
    250          	//
    251          	TA0R = 0;
    252          	TA0CTL 	 = TASSEL_2 + MC_1 + ID_0;  // SMCLK, up mode, div = 1
    253          	TA0CCR0  = SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
    254          	TA0CCTL0 = CCIE;					// Разрешаем прерывание таймера по достижению значения TACCCR0.
    255          	//
    256          	_BIS_SR(GIE);    					// Разрешаем прерывания
    257          
    258          }
    259          
    260          
    261          //--------------------------------------------------------------------------------
    262          // Function		: void SoundStart(u8 snd_ind)
    263          // Parameters	: period in us (1..32768) - for 16 MHz DCO
    264          // Return		: None
    265          // Description	: Function initiates 
    266          //--------------------------------------------------------------------------------
    267          void Timer_A_Off(void) {
    268          	_BIC_SR(GIE);    			// Запрещаем прерывания
    269          	//
    270          	TACTL = 0;  
    271          	TACCTL0 = 0;				// Запрещаем прерывание таймера по достижению значения TACCCR0.
    272          	//
    273          //	fLPM3 = 1;					// Включаем режим энергосбережения		
    274          	//
    275          	_BIS_SR(GIE);    			// Разрешаем прерывания
    276          
    277          }
    278          
    279          
    280          //--------------------------------------------------------------------------------
    281          // Function		: void LedValueManager(void)
    282          // Parameters	: None
    283          // Return		: None
    284          // Description	: 
    285          //--------------------------------------------------------------------------------
    286          void LedValueManager(void) {
    287            /*
    288          	if (DeviceFault.byte) {
    289          		DeviceMode = MODE_FAULT;
    290          		led_r = 0;
    291          		
    292          		if (DeviceFault.fELStrobNone) {
    293          			// Electrical sync is fault
    294          			led_y = LED_PULSE_3;
    295          		}else
    296          		if (DeviceFault.fSignal_Hi) {
    297          			// Level signal is big
    298          			led_y = LED_PULSE_2;
    299          		}else
    300          		if (DeviceFault.fSignal_Low) {
    301          			// Level signal is big
    302          			led_y = LED_PULSE_1;
    303          		}else	
    304          		if (DeviceFault.fFaultDrift) {
    305          			// Level signal is big
    306          			led_y = LED_PULSE_4;
    307          		}
    308          	}else{
    309          		if (DeviceMode == MODE_FAULT) {
    310          			DeviceMode = MODE_NORM;
    311          			led_r = 0;
    312          			led_y = 0;
    313          		}
    314          	}
    315            */
    316          }
    317          
    318          //========================================================
    319          //                 ---  M A I N  ----
    320          //========================================================
    321          //--------------------------------------------------------------------------------
    322          // Function		: void main(void)
    323          // Parameters	: None
    324          // Return		: None
    325          // Description	: Main function. Contains main loop.
    326          //--------------------------------------------------------------------------------
    327          void main(void) {
    328          	u8	led_clk;
    329          	u16	led_timer = 0;
    330          	// Initialization variables and GPIO
    331          	
    332          	WDTCTL = WDTPW + WDTHOLD;				// отключаем сторожевой таймер
    333          
    334          	// GIPIO Init
    335          	GPIO_Init();
    336          		
    337          	// Init internal RC osc.
    338          	BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
    339          	DCOCTL =  CALDCO_1MHZ;
    340          	
    341          	DelayMs(500);
    342          	
    343          	// Initialization code for VLO
    344          	__set_R4_register(0);
    345          	//
    346          	BCSCTL3 |= LFXT1S_2;                    // Select VLO as low freq clock
    347          	// End initialization code
    348          	
    349          	WDTCTL = WDT_ADLY_250;                   // Interval timer	/* for 50 ms */
    350          	//WDTCTL = WDT_ADLY_1_9;                   // Interval timer	/* for 5.9 ms */
    351          	IE1 |= WDTIE;                           // Enable WDT interrupt
    352          	//
    353          	fLPM3 = 1;								// Enable LOW power mode
    354          	//
    355          	if (IFG1 & WDTIFG) {
    356          		// Reset WDT
    357          		#if (SYS_FAULT_ENABLE == 1)
    358          		DeviceFault.fFaultSWReset = 1;
    359          		#endif
    360          	}
    361          	IFG1 = 0;
    362          	//	
    363          	DeviceMode = MODE_NORM;
    364          	
    365          	//!!!!
    366          //	TEST2_DIR |= TEST2_BIT;
    367          
    368          	DelayMs(1000);
    369          	
    370          	Led_Flash(5);
    371          	DelayMs(300);
    372          	Led_Flash(5);
    373          	
    374          	DelayMs(3000);
    375          	
    376          	_BIS_SR(GIE);    					// Interrupt enable
    377          	DeviceStart();
    378          
    379          	cfg_reg = CONFIG->config_reg;
    380          	
    381          	Timer_A0_Init();
    382          	
    383          	
    384          // *****************************************************************
    385          // ******************   M A I N   L O O P  *************************
    386          // *****************************************************************
    387          	while(1) {
    388          //-------------------------------------------------------------------------------
    389          		//
    390          		// ******** Обработчики событий ********
    391          		//
    392          //-------------------------------------------------------------------------------
    393          		
    394          //-------------------------------------------------------------------------------
    395          // TimerA0 Event		
    396          //-------------------------------------------------------------------------------
    397          		if (fTimerA_On) {				// Получен следующий интервал timer
    398          			fTimerA_On = 0;
    399          /*			
    400          			BCSCTL1 = CALBC1_16MHZ; 					// Используем частоту 8 MГц
    401          			DCOCTL =  CALDCO_16MHZ;
    402          			//
    403          			TA1CCR0  = 16 * SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
    404          			//
    405          			
    406          			_BIC_SR(GIE);    			// Запрещаем прерывания
    407          			Timer_A_Off();
    408          			_BIS_SR(GIE);    			// Разрешаем прерывания
    409          			
    410          			//TEST2_CLR();
    411          			
    412          			timerA1_blank = 4;
    413          */			
    414          		}
    415          
    416          //-------------------------------------------------------------------------------
    417          // fTimer50msOn Event				
    418          //-------------------------------------------------------------------------------
    419          		if (fTimer50msOn) {		// Получен следующий 50мс интервал
    420          			fTimer50msOn = 0;
    421          			//
    422          			Timer50msCounter = 0;
    423          		}
    424          		
    425          //-------------------------------------------------------------------------------
    426          // TimerA1 Event (SysTick)
    427          //-------------------------------------------------------------------------------
    428          		if (fTimerA1_On) {				// Получен следующий интервал timer
    429          			fTimerA1_On = 0;
    430          			
    431          			//TEST2_CLR();
    432          			//TEST2_OUT ^= TEST2_BIT;
    433          			
    434          			//
    435          			if (timerMain) {
    436          				timerMain--;
    437          				if (timerMain == 1) {
    438          					if (DeviceMode == MODE_TEST) {
    439          						DeviceMode = MODE_NORM;
    440          						RED_CLR();
    441          						YEL_CLR();
    442          					}
    443          				}
    444          			}
    445          
    446          	/*		
    447          			if (timerA1_blank) {
    448          				timerA1_blank--;
    449          			}else{
    450          
    451          				// Indication
    452          				//
    453          				if (light_timer) {
    454          					if ((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREFIRE)) {
    455          						RED_SET();
    456          						YEL_CLR();
    457          					}else
    458          					//
    459          					if (DeviceMode == MODE_CALIBR) {
    460          						RED_SET();
    461          						YEL_SET();
    462          					}
    463          					//
    464          					light_timer--;
    465          				}else{
    466          					//
    467          					if ((DeviceMode == MODE_NORM) || (DeviceMode == MODE_CALIBR) || (DeviceMode == MODE_PREFIRE)) {
    468          						RED_CLR();
    469          						YEL_CLR();
    470          					}
    471          				}
    472          
    473          			} // End indication
    474          			//
    475          */
    476          			
    477          		} // if (fTimer50msOn)
    478          
    479          	} // while(1)
    480          }
    481          
    482          
    483          //--------------------------------------------------------------------------------
    484          // Function		: __interrupt void watchdog_timer (void)
    485          // Parameters	: None
    486          // Return		: None
    487          // Description	: WDT Interrupt routine
    488          //--------------------------------------------------------------------------------
    489          #pragma vector=WDT_VECTOR
    490          __interrupt void watchdog_timer (void) {
    491          	
    492          	if (fTimer50msOn) {
    493          		if (++Timer50msCounter == 0) {		// > ~ 12sec
    494          			//!!!WDTCTL = WDTCTL;				// Hardware RESET
    495          		}
    496          	}
    497          	fTimer50msOn = 1;
    498          	
    499          	__bic_SR_register_on_exit(LPM3_bits);                   // Clear LPM3 bits from 0(SR)
    500          }
    501          
    502          
    503          
    504          
    505          
    506          
    507          
    508          
    509          //--------------------------------------------------------------------------------
    510          // Function		: void Led_Flash(u16 duration)
    511          // Parameters	: duration - duration Red LED flash in ms
    512          // Return		: None
    513          // Description	: Flashing red LED
    514          //--------------------------------------------------------------------------------
    515          void Led_Flash(u16 duration) {
    516          	RED_SET();
    517          	DelayMs(duration);
    518          	RED_CLR();
    519          }
    520          
    521          
    522          
    523          
    524          
    525          //--------------------------------------------------------------------------------
    526          // Function		: u16 GetVCC(u8 boost_stop)
    527          // Parameters	: boost_stop = 1 - if need call BoostStop() after measure
    528          // Return		: Value in 10mV (for example 250 = 2.50V)
    529          // Description	: Measurement the voltage VCC
    530          //--------------------------------------------------------------------------------
    531          u16 GetVCC(u8 boost_stop) {
    532          
    533                  u16 res=0;	
    534          /*	ADC_Measure(ADC_CH_VCC, 0, VCC_DATA_LEN);
    535          	//~~~
    536          	VREF_Off();
    537          	//
    538          	//	
    539          //	res = AverageData(adc_data1, VCC_DATA_LEN);
    540          	res = res * 64 / 218 + 2;						//~~res = ((u32)res * 301) / 1024 & Compensation dV(R38)=20mV (max=302)
    541          */
    542          	return (res);			
    543          }
    544          
    545          //--------------------------------------------------------------------------------
    546          // Function		: void ADC10_ISR(void)
    547          // Parameters	: None
    548          // Return		: None
    549          // Description	: ADC10 interrupt service routine
    550          //--------------------------------------------------------------------------------
    551          #pragma vector=ADC10_VECTOR
    552          __interrupt void ADC10_ISR(void) {
    553          
    554          	//ADC10AE0 &= ~0x0F;                      // Save only VRef Out
    555          	adc_process = 0;
    556          	fEndOfSamples = 1;
    557          	
    558          	//__bic_SR_register_on_exit(CPUOFF);      // Clear CPUOFF bit from 0(SR)
    559          	
    560          }
    561          
    562          //--------------------------------------------------------------------------------
    563          // Function		: void DeviceDiagnostics(void)
    564          // Parameters	: None
    565          // Return		: None
    566          // Description	: Procedure of the diagnostics device
    567          //--------------------------------------------------------------------------------
    568          void DeviceDiagnostics(void) {
    569          	
    570          	//
    571          #if (TEMP_DET_ENABLE == 1)
    572          //	ADC_Measure_TEMP(ADC_CH_TEMP, REFOUT, ADC_CH_DATA_LEN);
    573          //	tempC = AverageData(adc_data1, ADC_CH_DATA_LEN);
    574          #endif
    575          	
    576          	// Diagnostic BOOST	
    577          	//
    578          //	DelayMs(100);
    579          	//
    580          	//
    581          		
    582          #if (CRC_ENABLE == 1)
    583          	// Check CS of Memory
    584          	DeviceFault.fFaultCRC = 0;
    585          	if (GetPropertiesCS() != CONFIG->CS) {
    586          		DeviceFault.fFaultCRC = 1;
    587          	}
    588          #endif
    589          }
    590          
    591          //--------------------------------------------------------------------------------
    592          // Function		: void u8 JP1_Define(void)
    593          // Parameters	: None
    594          // Return		: 0 - JP1 Open, 1 - JP1 Close
    595          // Description	: Definition of JP1 state
    596          //--------------------------------------------------------------------------------
    597          void JP1_Define(void) {
    598          /*	u16 buf[4];
    599          	u16 res;
    600          	
    601          	res = ADC_Measure_Simple(ADC_BUT, buf, 4);
    602          	
    603          	if (res > 600) return; 
    604          	if (res > 100) {
    605          		jp1_state = 0;		// JP1 is Open 
    606          	}else{
    607          		jp1_state = 1;		// JP1 is Close
    608          	}	
    609          */
    610                  
    611          	return;	
    612          }
    613          
    614          
    615          // End of main.c

Errors: 1
Warnings: 2
