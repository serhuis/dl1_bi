###############################################################################
#
# IAR C/C++ Compiler V6.40.1.950/W32 for MSP430           17/Mar/2017  17:40:16
# Copyright 1996-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  regvar
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430
#    Source file   =  E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\main.c
#    Command line  =  
#        E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\main.c -lcN
#        E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\IAR\Debug\List -o
#        E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\IAR\Debug\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430G2332__ -e --double=32 --regvar_r4 --dlib_config "C:\Program
#        Files (x86)\IAR Systems\Embedded Workbench 7.3\430\lib\dlib\dl430fn.h"
#        -I ..\ -I .\ -On
#    List file     =  
#        E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\IAR\Debug\List\main.lst
#    Object file   =  
#        E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\IAR\Debug\Obj\main.r43
#
###############################################################################

E:\_ARTON_PROJ\Arton-DL1-R\BI\soft\git\main.c
      1          /**********************************************************************************
      2           *
      3           *      ASD-10QR MAIN routine
      4           * 
      5           **********************************************************************************
      6           * FileName:        main.c
      7           * Version:			1.00
      8           *
      9           * Processor:       MSP430G2xxx
     10           * Complier:        IAR Workbench for MSP430 v4.50 or higher
     11           *                  
     12           * Company:         ARTON
     13           *
     14           * Software License Agreement
     15           *
     16           * The software supplied herewith by ARTON Incorporated
     17           * (the "Company") for its devices is intended and
     18           * supplied to you, the Company's customer, for use solely and
     19           * exclusively on ARTON Inc products. The
     20           * software is owned by the Company and/or its Author, and is
     21           * protected under applicable copyright laws. All rights are reserved.
     22           * Any use in violation of the foregoing restrictions may subject the
     23           * user to criminal sanctions under applicable laws, as well as to
     24           * civil liability for the breach of the terms and conditions of this
     25           * license.
     26           *
     27           * THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
     28           * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
     29           * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
     30           * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
     31           * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
     32           * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
     33           *
     34           *
     35           * Author               Date      	Version	  		Comment
     36           *--------------------------------------------------------------------------------
     37           * Oleg Semeniuk	 16.01.2014    	1.00		Release for v1.00
     38           *
     39           *********************************************************************************/
     40          
     41          
     42          /*********************************************************************************/
     43          /*                                 INCLUDES                                      */
     44          /*********************************************************************************/
     45          
     46          
     47          #include <stdio.h>                    /* standard I/O .h-file                */
     48          #include <string.h>                   /* string and memory functions         */
     49          
     50          
     51          #include  "main.h"
     52          
     53          
     54          
     55          /*********************************************************************************/
     56          /*                                 VARIABLES                                     */
     57          /*********************************************************************************/
     58          
     59          __regvar __no_init tFlags 	f 	 @ __R4; 	// Set of state machine flags
     60          
     61          //
     62          u16		timerMain;					// Текущее значение главного таймера
     63          u16		mainPeriodCounter;			// Counter of main time period
     64          u8 		DeviceMode; 				// Mode of device
     65          
     66          tFault	DeviceFault = {0};			// Current Faults flags
     67          
     68          u8 		Timer50msCounter = 0;		// Counter of 50ms ticks
     69          /*
     70          volatile u32	led_r;
     71          volatile u32	led_y;
     72          volatile u32	led_sh = 0;
     73          */
     74          u8 		fTimerA1_On = 0;
     75          u8 		timerA1_blank = 0;
     76          tCfgReg	cfg_reg;
     77          u8	jp1_state = 0;	// 0 - JP1 Open, 1 - JP1 Close
     78          
     79          u8	adc_process = 0;		// ADC low level semafore
     80          u16	light_timer = 1;	// For led lighting
     81          
     82          u8	sync_timer = SYNC_PERIOD;		// For led lighting syncronisation
     83          u8	ir_timer  = IR_TIMEOUT;
     84          
     85          
     86          
     87          
     88          /*********************************************************************************/
     89          /*                                FUNCTIONS                                      */
     90          /*********************************************************************************/
     91          // --- Declarations ---
     92          
     93          //u16  AverageData(u16 * data_ptr, u8 len);
     94          //u8   RX_PacketParser(void);
     95          //void ADC_Measure(u16 ch, u16 refout, u8 count);
     96          //void ADC_Measure_TEMP(u16 ch, u16 refout, u8 count);
     97          
     98          
     99          void JP1_Define(void);
    100          
    101          
    102          
    103          
    104          //--------------------------------------------------------------------------------
    105          // Function		: void DeviceStart(void)
    106          // Parameters	: None
    107          // Return		: None
    108          // Description	: Function executes initialization variable at start of device
    109          //--------------------------------------------------------------------------------
    110          void DeviceStart(void) {
    111          
    112          	DeviceFault.byte = 0;		// Reset faults flags
    113          	//		
    114          	VLO_TimerCalibr();			// Calibration VLO Timer
    115          	//
    116          }
    117          
    118          
    119          //--------------------------------------------------------------------------------
    120          // Function		: void LedValueManager(void)
    121          // Parameters	: None
    122          // Return		: None
    123          // Description	: 
    124          //--------------------------------------------------------------------------------
    125          void LedValueManager(void) {
    126            /*
    127          	if (DeviceFault.byte) {
    128          		DeviceMode = MODE_FAULT;
    129          		led_r = 0;
    130          		
    131          		if (DeviceFault.fELStrobNone) {
    132          			// Electrical sync is fault
    133          			led_y = LED_PULSE_3;
    134          		}else
    135          		if (DeviceFault.fSignal_Hi) {
    136          			// Level signal is big
    137          			led_y = LED_PULSE_2;
    138          		}else
    139          		if (DeviceFault.fSignal_Low) {
    140          			// Level signal is big
    141          			led_y = LED_PULSE_1;
    142          		}else	
    143          		if (DeviceFault.fFaultDrift) {
    144          			// Level signal is big
    145          			led_y = LED_PULSE_4;
    146          		}
    147          	}else{
    148          		if (DeviceMode == MODE_FAULT) {
    149          			DeviceMode = MODE_NORM;
    150          			led_r = 0;
    151          			led_y = 0;
    152          		}
    153          	}
    154            */
    155          }
    156          
    157          //========================================================
    158          //                 ---  M A I N  ----
    159          //========================================================
    160          //--------------------------------------------------------------------------------
    161          // Function		: void main(void)
    162          // Parameters	: None
    163          // Return		: None
    164          // Description	: Main function. Contains main loop.
    165          //--------------------------------------------------------------------------------
    166          void main(void) {
    167          	u8	ir_num;
    168          //	u16	led_timer = 0;
    169          	// Initialization variables and GPIO
    170          	
    171          	WDTCTL = WDTPW + WDTHOLD;				// отключаем сторожевой таймер
    172          	
    173          	BCSCTL1 = CALBC1_1MHZ; 						// Init internal RC osc.
    174          	DCOCTL =  CALDCO_1MHZ;						// Используем частоту 1 MГц0.
    175          	__set_R4_register(0);							
    176          	
    177          	// Initialization code for VLO
    178          	BCSCTL3 |= LFXT1S_2;                    // Select VLO for low freq clock, capacitor off
    179          	
    180          	WDTCTL = WDT_ADLY_1000;                   	// Interval timer	/* for 1000 ms */
    181          	IE1 |= WDTIE|NMIIE;                           	// Enable WDT interrupt
    182          	_BIS_SR(GIE);    					// Interrupt enable
    183          	
    184          	__bis_SR_register(LPM1_bits);
    185          		
    186          	WDTCTL = WDTPW + WDTHOLD;				// отключаем сторожевой таймер	
    187          		_BIC_SR(GIE);	
    188          
    189          	IFG1 = 0;												//clear global interrupt flag
    190          
    191          	GPIO_Init();										// GIPIO Init
    192          
    193          	distance = DISTANCE_PROCESSING;
    194          
    195          	
    196          	Led_Flash(10);
    197          	DelayMs(200);
    198          	Led_Flash(10);
    199          
    200          		_BIS_SR(GIE);    					// Interrupt enable
    201          //	DeviceStart();									// Calibration VLO Timer
    202          	VLO_TimerCalibr();			// Calibration VLO Timer
    203          	SysTimerInit();
    204          //	__bis_SR_register(LPM1_bits);
    205          
    206          	
    207          // *****************************************************************
    208          // ******************   M A I N   L O O P  *************************
    209          // *****************************************************************
    210          	while(1) {
    211          //-------------------------------------------------------------------------------
    212          		//
    213          		// ******** Обработчики событий ********
    214          		//
    215          //-------------------------------------------------------------------------------
    216          		
    217          //-------------------------------------------------------------------------------
    218          // old TimerA0 Event		
    219          //-------------------------------------------------------------------------------
    220          /*
    221          		if (fTimerA_On) {				// Получен следующий интервал timer
    222          			fTimerA_On = 0;
    223          			
    224          			BCSCTL1 = CALBC1_16MHZ; 					// Используем частоту 8 MГц
    225          			DCOCTL =  CALDCO_16MHZ;
    226          			//
    227          			TA1CCR0  = 16 * SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
    228          			//
    229          			
    230          			_BIC_SR(GIE);    			// Запрещаем прерывания
    231          			Timer_A_Off();
    232          			_BIS_SR(GIE);    			// Разрешаем прерывания
    233          			
    234          			//TEST2_CLR();
    235          			
    236          			timerA1_blank = 4;
    237          			
    238          		}
    239          */
    240          //-------------------------------------------------------------------------------
    241          // fTimer50msOn Event				
    242          //-------------------------------------------------------------------------------
    243          		if (fTimer50msOn) {		// Получен следующий 50мс интервал
    244          			fTimer50msOn = 0;
    245          			//
    246          			Timer50msCounter = 0;
    247          
    248          		}
    249          		
    250          //-------------------------------------------------------------------------------
    251          // fIrTimerOn Event				
    252          //-------------------------------------------------------------------------------
    253          		if(fIrTimerOn)
    254          			{
    255          //				if(ir_timer--);
    256          //				else
    257          //				{
    258          
    259          					fIrTimerOn = 0;
    260          					for(ir_num = 0; ir_num < IR_PULSES; ir_num++)
    261          					{
    262          				
    263          						if(distance == DISTANCE_FAR){
    264          							IR_SYNC_SET();
    265          							DelayUs(IR_DUTY);
    266          							IR_SYNC_CLR();
    267          							DelayUs(IR_PAUSE);
    268          						}
    269          
    270          						else if(distance == DISTANCE_NEAR)
    271          						{
    272          							IRED_SET();
    273          							DelayUs(IR_DUTY);
    274          							IRED_CLR();
    275          							DelayUs(IR_PAUSE);
    276          						}
    277          							
    278          					}
    279          					
    280          					fscanDistance =1;								//start scaning distance
    281          //					LPM0;
    282          //__bis_SR_register(LPM1_bits);
    283          			}
    284          		
    285          		
    286          //-------------------------------------------------------------------------------
    287          // TimerA0 SysTick
    288          //-------------------------------------------------------------------------------
    289          		
    290          		if (fTimerA_On) {				// Получен следующий интервал timer
    291          			fTimerA_On = 0;
    292          			
    293          			if(sync_timer--)
    294          			{
    295          				fStartPulse = 0;
    296          			}
    297          			else
    298          			{
    299          				fStartPulse = 1;					//enable sync pulse
    300          				sync_timer = SYNC_PERIOD;
    301          			}
    302          			
    303          			if(fStartPulse)
    304          			{
    305          				fStartPulse =0;
    306          				
    307          
    308          				LN_SYNC_SET();	
    309          				DelayUs(100);
    310          				LN_SYNC_CLR();
    311          				
    312          //				ir_timer  = IR_TIMEOUT;
    313          				
    314          				T0_delay();
    315          				
    316          			}
    317          			
    318          	
    319          			if(fscanDistance)
    320          			{
    321          				 distance = CheckDistance();
    322          				 if(distance != DISTANCE_PROCESSING)
    323          					 fscanDistance = 0; 
    324          			}
    325          //	Indication update			
    326          			RED_CLR();
    327          			YEL_CLR();			
    328          			if (timerA1_blank) 
    329          			{
    330          				timerA1_blank--;
    331          			}
    332          			else
    333          			{
    334          				timerA1_blank = 50;
    335          
    336          				// Indication
    337          				//
    338          				if (light_timer--) 
    339          				{
    340          					if(distance == DISTANCE_FAR)
    341          						YEL_SET();
    342          					else if(distance == DISTANCE_NEAR)
    343          						RED_SET();
    344          					else
    345          					{
    346          						YEL_SET();
    347          						RED_SET();
    348          					}
    349          				}
    350          				else
    351          				{
    352          					light_timer = 1;
    353          						RED_CLR();
    354          						YEL_CLR();
    355          				}
    356          			}
    357          
    358          //	end of Indication update
    359          		}//fTimerA_On
    360          
    361          	} // while(1)
    362          }//main
    363          
    364          
    365          //--------------------------------------------------------------------------------
    366          // Function		: __interrupt void watchdog_timer (void)
    367          // Parameters	: None
    368          // Return		: None
    369          // Description	: WDT Interrupt routine
    370          //--------------------------------------------------------------------------------
    371          #pragma vector=WDT_VECTOR
    372          __interrupt void watchdog_timer (void) {
    373          	
    374          	if (fTimer50msOn) {
    375          		if (++Timer50msCounter == 0) {		// > ~ 12sec
    376          			//!!!WDTCTL = WDTCTL;				// Hardware RESET
    377          		}
    378          	}
    379          	fTimer50msOn = 1;
    380          	
    381          
    382          	
    383          	__bic_SR_register_on_exit(LPM1_bits);                   // Clear LPM3 bits from 0(SR)
    384          }
    385          
    386          
    387          
    388          
    389          //--------------------------------------------------------------------------------
    390          // Function		: void Led_Flash(u16 duration)
    391          // Parameters	: duration - duration Red LED flash in ms
    392          // Return		: None
    393          // Description	: Flashing red LED
    394          //--------------------------------------------------------------------------------
    395          void Led_Flash(u16 duration) {
    396          	RED_SET();
    397          	YEL_SET();
    398          	DelayMs(duration);
    399          	RED_CLR();
    400          	YEL_CLR();
    401          }
    402          
    403          //--------------------------------------------------------------------------------
    404          // Function		: void ADC10_ISR(void)
    405          // Parameters	: None
    406          // Return		: None
    407          // Description	: ADC10 interrupt service routine
    408          //--------------------------------------------------------------------------------
    409          #pragma vector=ADC10_VECTOR
    410          __interrupt void ADC10_ISR(void) {
    411          
    412          	//ADC10AE0 &= ~0x0F;                      // Save only VRef Out
    413          	//adc_process = 0;
    414          	//fEndOfSamples = 1;
    415          	
    416          	//__bic_SR_register_on_exit(CPUOFF);      // Clear CPUOFF bit from 0(SR)
    417          	
    418          }
    419          
    420          //--------------------------------------------------------------------------------
    421          // Function		: void DeviceDiagnostics(void)
    422          // Parameters	: None
    423          // Return		: None
    424          // Description	: Procedure of the diagnostics device
    425          //--------------------------------------------------------------------------------
    426          void DeviceDiagnostics(void) {
    427          	
    428          	//
    429          #if (TEMP_DET_ENABLE == 1)
    430          //	ADC_Measure_TEMP(ADC_CH_TEMP, REFOUT, ADC_CH_DATA_LEN);
    431          //	tempC = AverageData(adc_data1, ADC_CH_DATA_LEN);
    432          #endif
    433          	
    434          	// Diagnostic BOOST	
    435          	//
    436          //	DelayMs(100);
    437          	//
    438          	//
    439          		
    440          #if (CRC_ENABLE == 1)
    441          	// Check CS of Memory
    442          	DeviceFault.fFaultCRC = 0;
    443          	if (GetPropertiesCS() != CONFIG->CS) {
    444          		DeviceFault.fFaultCRC = 1;
    445          	}
    446          #endif
    447          }
    448          
    449          //--------------------------------------------------------------------------------
    450          // Function		: void u8 JP1_Define(void)
    451          // Parameters	: None
    452          // Return		: 0 - JP1 Open, 1 - JP1 Close
    453          // Description	: Definition of JP1 state
    454          //--------------------------------------------------------------------------------
    455          void JP1_Define(void) {
    456          /*	u16 buf[4];
    457          	u16 res;
    458          	
    459          	res = ADC_Measure_Simple(ADC_BUT, buf, 4);
    460          	
    461          	if (res > 600) return; 
    462          	if (res > 100) {
    463          		jp1_state = 0;		// JP1 is Open 
    464          	}else{
    465          		jp1_state = 1;		// JP1 is Close
    466          	}	
    467          */
    468                  
    469          	return;	
    470          }
    471          
    472          
    473          // End of main.c

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   ADC10_ISR
      2   DeviceDiagnostics
        2   -> GetPropertiesCS
      2   DeviceStart
        0   -> VLO_TimerCalibr
      2   JP1_Define
      2   LedValueManager
      4   Led_Flash
        4   -> DelayMs
      2   main
        2   -> CheckDistance
        2   -> DelayMs
        2   -> DelayUs
        2   -> GPIO_Init
        2   -> Led_Flash
        2   -> SysTimerInit
        2   -> T0_delay
        2   -> VLO_TimerCalibr
      4   watchdog_timer


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for ir_timer>
       2  ?<Initializer for light_timer>
       1  ?<Initializer for sync_timer>
       2  ADC10_ISR
       2  ADC10_ISR::??INTVEC 10
       1  BCSCTL1
       1  BCSCTL3
       1  CALBC1_1MHZ
       1  CALDCO_1MHZ
       1  DCOCTL
      24  DeviceDiagnostics
       1  DeviceFault
       1  DeviceMode
       8  DeviceStart
       1  IE1
       1  IFG1
       2  JP1_Define
       2  LedValueManager
      30  Led_Flash
       1  P1OUT
       1  P2OUT
       1  Timer50msCounter
       2  WDTCTL
       1  adc_process
       2  cfg_reg
       2  f
       1  fTimerA1_On
       1  ir_timer
       1  jp1_state
       2  light_timer
     426  main
       2  mainPeriodCounter
       1  sync_timer
       1  timerA1_blank
       2  timerMain
      18  watchdog_timer
       2  watchdog_timer::??INTVEC 20

 
 512 bytes in segment CODE
  11 bytes in segment DATA16_AN
   4 bytes in segment DATA16_I
   4 bytes in segment DATA16_ID
  13 bytes in segment DATA16_Z
   4 bytes in segment INTVEC
   2 bytes in segment REGVAR_AN
 
 512 bytes of CODE     memory
   4 bytes of CONST    memory (+  4 bytes shared)
  17 bytes of DATA     memory (+ 11 bytes shared)
   0 bytes of REGISTER memory (+  2 bytes shared)

Errors: none
Warnings: 1
